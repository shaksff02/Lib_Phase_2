<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Phase 2 Instructions ‚Äì Full CRUD for Books (Comprehensive Backend Guide)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            line-height: 1.8;
            margin: 0;
            padding: 0;
            color: #1d1d1d;
            background: #f4f6fb;
        }
        header {
            background: #14274e;
            color: #fff;
            padding: 40px 20px;
        }
        header h1 {
            margin: 0 0 10px 0;
            font-size: 2.2em;
        }
        header p {
            margin: 0;
            max-width: 900px;
            font-size: 1.05em;
        }
        main {
            max-width: 1100px;
            margin: 24px auto 60px;
            padding: 0 20px;
        }
        section {
            background: #fff;
            border-radius: 12px;
            margin-bottom: 30px;
            padding: 28px 32px;
            box-shadow: 0 5px 16px rgba(20, 39, 78, 0.08);
        }
        h2 {
            color: #14274e;
            margin-top: 0;
            font-size: 1.8em;
            border-bottom: 3px solid #14274e;
            padding-bottom: 10px;
        }
        h3 {
            color: #1d2d50;
            font-size: 1.3em;
            margin-top: 25px;
            margin-bottom: 12px;
        }
        h4 {
            color: #2d3d60;
            font-size: 1.1em;
            margin-top: 18px;
        }
        pre {
            background: #0f172a;
            color: #e2e8f0;
            padding: 16px 18px;
            overflow-x: auto;
            border-radius: 6px;
            font-size: 14px;
            line-height: 1.5;
            border-left: 4px solid #3d5af1;
        }
        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
        }
        pre code {
            background: none;
            padding: 0;
        }
        ul {
            padding-left: 24px;
        }
        li {
            margin-bottom: 8px;
        }
        .callout {
            border-left: 5px solid #3d5af1;
            background: #e7ecff;
            padding: 16px 20px;
            border-radius: 8px;
            margin: 18px 0;
        }
        .warning {
            border-left: 5px solid #ff6b6b;
            background: #ffe6e6;
            padding: 16px 20px;
            border-radius: 8px;
            margin: 18px 0;
        }
        .tip {
            border-left: 5px solid #51cf66;
            background: #e6ffed;
            padding: 16px 20px;
            border-radius: 8px;
            margin: 18px 0;
        }
        .concept-box {
            background: #f8f9ff;
            border: 2px solid #3d5af1;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .concept-box h4 {
            margin-top: 0;
            color: #14274e;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #d9e1ff;
            padding: 12px 14px;
            text-align: left;
        }
        th {
            background: #edf2ff;
            color: #1d2d50;
            font-weight: 600;
        }
        tr:nth-child(even) {
            background: #f9faff;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 16px;
        }
        .grid div {
            background: #eef2ff;
            padding: 16px;
            border-radius: 10px;
            border-left: 4px solid #3d5af1;
        }
        footer {
            text-align: center;
            padding: 40px 20px 50px;
            color: #5e6a94;
            font-size: 1.05em;
        }
    </style>
</head>
<body>
<header>
    <h1>Phase 2 ‚Äì Full CRUD for Books (Comprehensive Backend Guide)</h1>
    <p>
        Phase 1 gave you a read-only view of books. Phase 2 transforms the system into a fully interactive library management tool
        with Create, Read, Update, and Delete (CRUD) operations. You'll learn Django forms, form validation, request handling (GET vs POST),
        the messages framework for user feedback, search/filtering, and how to build user-friendly interfaces. This comprehensive guide
        explains every backend concept in depth so you understand not just what to do, but why we architect it this way.
    </p>
</header>
<main>
    <section id="learning-goals">
        <h2>Learning Goals ‚Äì What You'll Master</h2>
        <div class="grid">
            <div>
                <h4>Forms & Validation</h4>
                <ul>
                    <li>ModelForm vs regular Form</li>
                    <li>Form field types & widgets</li>
                    <li>Built-in validation</li>
                    <li>Custom validation methods</li>
                </ul>
            </div>
            <div>
                <h4>Request Handling</h4>
                <ul>
                    <li>GET vs POST HTTP methods</li>
                    <li>Request object anatomy</li>
                    <li>Form submission workflow</li>
                    <li>CSRF protection</li>
                </ul>
            </div>
            <div>
                <h4>View Architecture</h4>
                <ul>
                    <li>Function-based view patterns</li>
                    <li>Context preparation</li>
                    <li>Redirects and reusability</li>
                    <li>Error handling</li>
                </ul>
            </div>
            <div>
                <h4>User Experience</h4>
                <ul>
                    <li>Django messages framework</li>
                    <li>Success/error feedback</li>
                    <li>Search & filtering ORM queries</li>
                    <li>URL naming conventions</li>
                </ul>
            </div>
        </div>
    </section>

    <section id="core-concepts">
        <h2>Core Backend Concepts ‚Äì Deep Dive</h2>

        <div class="concept-box">
            <h4>1. ModelForm vs Form ‚Äì Why ModelForm?</h4>
            <p><strong>Regular Form:</strong> You manually define every field:</p>
            <pre>
class BookForm(forms.Form):
    title = forms.CharField(max_length=200)
    author = forms.CharField(max_length=200)
    isbn = forms.CharField(max_length=13)
    # ... repeat for each field
            </pre>
            <p><strong>ModelForm:</strong> Automatically generates fields from model definition:</p>
            <pre>
class BookForm(forms.ModelForm):
    class Meta:
        model = Book
        fields = ['title', 'author', 'isbn', 'quantity']
            </pre>
            <p><strong>Why ModelForm is better:</strong></p>
            <ul>
                <li><strong>DRY (Don't Repeat Yourself):</strong> Define fields once in model, reuse in form</li>
                <li><strong>Automatic Validation:</strong> Form inherits model validation (unique constraints, max_length, etc.)</li>
                <li><strong>Easy Saving:</strong> <code>form.save()</code> automatically creates/updates the database object</li>
                <li><strong>Schema Consistency:</strong> If you change a model field, forms automatically update</li>
                <li><strong>Type Safety:</strong> Field types match database types (CharField ‚Üí text input, IntegerField ‚Üí number input)</li>
            </ul>
        </div>

        <div class="concept-box">
            <h4>2. HTTP GET vs POST ‚Äì Understanding Request Methods</h4>
            <p><strong>GET Request:</strong></p>
            <ul>
                <li>Used to <strong>retrieve data</strong> without modifying anything</li>
                <li>Data appears in URL (query string): <code>?search=Python&page=2</code></li>
                <li>Data is <strong>visible and limited in size</strong></li>
                <li>Can be bookmarked and cached</li>
                <li>Examples: search filters, pagination, reading data</li>
            </ul>
            <p><strong>POST Request:</strong></p>
            <ul>
                <li>Used to <strong>submit data that modifies something</strong></li>
                <li>Data is in request body (hidden from URL)</li>
                <li>Can handle large amounts of data</li>
                <li>Cannot be bookmarked</li>
                <li>Examples: creating, updating, deleting records</li>
            </ul>
            <p><strong>In your view:</strong></p>
            <pre>
if request.method == 'POST':
    # User submitted a form - process the data
    form = BookForm(request.POST)
    if form.is_valid():
        form.save()  # Save to database
        return redirect('myapp:book_list')
else:
    # GET request - display empty form
    form = BookForm()
            </pre>
            <p><strong>Why separate GET and POST?</strong></p>
            <ul>
                <li>Security: GET requests should never modify data (REST principle)</li>
                <li>Idempotency: Multiple GET requests have the same result; POST might create duplicates</li>
                <li>Semantics: Code is clearer about intent (show form vs process form)</li>
            </ul>
        </div>

        <div class="concept-box">
            <h4>3. CSRF Protection ‚Äì Why {% csrf_token %} Matters</h4>
            <p><strong>What is CSRF (Cross-Site Request Forgery)?</strong></p>
            <p>An attack where a malicious website tricks your user into submitting a form to OUR site without their knowledge:</p>
            <pre>
<!-- Malicious website -->
&lt;img src="http://oursite.com/books/delete/5/" /&gt;
<!-- This secretly sends a request to delete book 5! --></pre>
            <p><strong>How Django protects against CSRF:</strong></p>
            <ul>
                <li>Django generates a unique token for each form</li>
                <li><code>{% csrf_token %}</code> embeds this token in the form as a hidden field</li>
                <li>When form is submitted, Django validates the token matches the session</li>
                <li>If tokens don't match, the request is rejected (403 Forbidden)</li>
                <li>Attacker can't forge the token because it's unique per session</li>
            </ul>
            <p><strong>The token is different for every user and every form submission:</strong></p>
            <pre>
&lt;input type="hidden" name="csrfmiddlewaretoken" value="abc123xyz..." /&gt;
            </pre>
        </div>

        <div class="concept-box">
            <h4>4. Form Validation Pipeline ‚Äì Where & Why</h4>
            <p><strong>Level 1: Browser Validation (HTML5)</strong></p>
            <pre>
&lt;input type="email" required /&gt;  <!-- Browser checks before submission --></pre>
            <p>Fast feedback but <strong>can be bypassed</strong> (not reliable for security)</p>
            <p><strong>Level 2: Django Form Validation</strong></p>
            <pre>
class BookForm(forms.ModelForm):
    def clean_isbn(self):
        isbn = self.cleaned_data.get('isbn')
        if len(isbn) != 13:
            raise forms.ValidationError("ISBN must be 13 characters")
        return isbn
            </pre>
            <p>Server-side validation <strong>cannot be bypassed</strong>. This is where real security happens.</p>
            <p><strong>Level 3: Model Validation</strong></p>
            <ul>
                <li><code>unique=True</code> ‚Äì Database enforces no duplicates</li>
                <li><code>max_length</code> ‚Äì CharField limits text length</li>
                <li>These are enforced even if form validation is skipped</li>
            </ul>
            <p><strong>Why multiple levels?</strong></p>
            <ul>
                <li>Browser validation: Better UX (instant feedback)</li>
                <li>Form validation: Catch business logic errors</li>
                <li>Database validation: Last line of defense against corruption</li>
            </ul>
        </div>

        <div class="concept-box">
            <h4>5. The Q Object ‚Äì Building Complex Filters</h4>
            <p><strong>Problem:</strong> You need to search books by title OR author (multiple OR conditions):</p>
            <pre>
# This WON'T work (only filters by one condition):
Book.objects.filter(title='Python', author='Guido')  # AND logic

# This DOES work (searches for either title OR author):
from django.db.models import Q

Book.objects.filter(
    Q(title__icontains='Python') | Q(author__icontains='Python')
)
            </pre>
            <p><strong>Q object operators:</strong></p>
            <ul>
                <li><code>|</code> (pipe) = OR operator</li>
                <li><code>&</code> (ampersand) = AND operator</li>
                <li><code>~</code> (tilde) = NOT operator</li>
            </ul>
            <p><strong>Real-world example in our search:</strong></p>
            <pre>
# Search across multiple fields simultaneously
books = Book.objects.filter(
    Q(title__icontains=search_query) |
    Q(author__icontains=search_query) |
    Q(isbn__icontains=search_query)
)
            </pre>
            <p>This finds books where search term appears in ANY field (title, author, or ISBN)</p>
        </div>

        <div class="concept-box">
            <h4>6. Django Messages Framework ‚Äì User Feedback Architecture</h4>
            <p><strong>Why we need messages:</strong></p>
            <p>After a form submission, we redirect the user. But how do they know if it succeeded?</p>
            <pre>
# Bad UX: User has no feedback
form.save()
return redirect('myapp:book_list')  # User left hanging!

# Good UX: Tell the user what happened
form.save()
messages.success(request, "Book created successfully!")
return redirect('myapp:book_list')  # User knows it worked
            </pre>
            <p><strong>How messages work behind the scenes:</strong></p>
            <ul>
                <li>Messages stored in session (survives redirect)</li>
                <li>Template displays messages: <code>{% for message in messages %}</code></li>
                <li>After display, messages are automatically cleared</li>
                <li>Different levels: success, error, warning, info, debug</li>
            </ul>
            <p><strong>Message levels explained:</strong></p>
            <table>
                <tr>
                    <th>Level</th>
                    <th>Usage</th>
                    <th>Example</th>
                </tr>
                <tr>
                    <td><code>messages.success()</code></td>
                    <td>Operation succeeded</td>
                    <td>"Book created successfully!"</td>
                </tr>
                <tr>
                    <td><code>messages.error()</code></td>
                    <td>Operation failed</td>
                    <td>"Failed to delete book (in use)"</td>
                </tr>
                <tr>
                    <td><code>messages.warning()</code></td>
                    <td>Caution about something</td>
                    <td>"Low inventory warning"</td>
                </tr>
                <tr>
                    <td><code>messages.info()</code></td>
                    <td>Informational message</td>
                    <td>"3 books updated"</td>
                </tr>
            </table>
        </div>

        <div class="concept-box">
            <h4>7. View Pattern: Reusing Forms for Create & Update</h4>
            <p><strong>The Challenge:</strong> Create and update views are almost identical. Can we reuse the same template?</p>
            <p><strong>Solution: Use instance parameter in ModelForm</strong></p>
            <pre>
# For CREATE (new book):
form = BookForm()  # Empty form

# For UPDATE (existing book):
book = Book.objects.get(pk=1)
form = BookForm(instance=book)  # Pre-filled form
            </pre>
            <p><strong>How it works:</strong></p>
            <ul>
                <li><code>form = BookForm()</code> ‚Äì Creates empty form (all fields blank)</li>
                <li><code>form = BookForm(instance=book)</code> ‚Äì Pre-fills form with book data</li>
                <li><code>form.save()</code> ‚Äì Creates new record OR updates existing record (detects via instance)</li>
            </ul>
            <p><strong>Same form template works for both:</strong></p>
            <pre>
context = {
    'form': form,
    'title': 'Add New Book',          # For CREATE
    'button_text': 'Create Book'
}
# OR
context = {
    'form': form,
    'title': f'Edit: {book.title}',   # For UPDATE
    'button_text': 'Update Book'
}
            </pre>
            <p>Template doesn't change ‚Äì it just displays different text and uses the same form!</p>
        </div>

        <div class="concept-box">
            <h4>8. get_object_or_404 ‚Äì Handling Missing Records</h4>
            <p><strong>The Problem:</strong> What if user requests a book that doesn't exist?</p>
            <pre>
# Bad: Returns None, code crashes later
book = Book.objects.get(pk=99)  # Throws DoesNotExist exception

# Good: Returns 404 page automatically
from django.shortcuts import get_object_or_404
book = get_object_or_404(Book, pk=99)  # Returns 404 page
            </pre>
            <p><strong>Why this matters:</strong></p>
            <ul>
                <li>User gets proper 404 page instead of 500 error</li>
                <li>Search engines recognize 404 (not found) vs 500 (server error)</li>
                <li>Cleaner code (no need for try/except blocks)</li>
                <li>Professional user experience</li>
            </ul>
        </div>

        <div class="concept-box">
            <h4>9. QuerySet Filtering with Conditions ‚Äì Building Smart Searches</h4>
            <p><strong>Our library search needs to support:</strong></p>
            <ul>
                <li>Search by title/author/ISBN</li>
                <li>Filter by availability (in stock or out of stock)</li>
                <li>Combine both filters</li>
            </ul>
            <p><strong>How it works in the view:</strong></p>
            <pre>
# Start with all books
books = Book.objects.all()

# Apply search filter IF search query provided
search_query = request.GET.get('search', '')
if search_query:
    books = books.filter(
        Q(title__icontains=search_query) |
        Q(author__icontains=search_query) |
        Q(isbn__icontains=search_query)
    )

# Apply availability filter IF filter provided
filter_status = request.GET.get('status', 'all')
if filter_status == 'available':
    books = books.filter(quantity__gt=0)
elif filter_status == 'unavailable':
    books = books.filter(quantity=0)

# Final result: books matching BOTH conditions
            </pre>
            <p><strong>Why chain filters?</strong></p>
            <ul>
                <li>Filters are chainable ‚Äì each .filter() narrows results</li>
                <li>No database hit yet (lazy evaluation) ‚Äì queries only when needed</li>
                <li>Each filter combines with AND logic</li>
                <li>More readable than writing one massive WHERE clause</li>
            </ul>
        </div>

        <div class="concept-box">
            <h4>10. Context Passing ‚Äì Data from View to Template</h4>
            <p><strong>Context is a dictionary that carries data from view to template:</strong></p>
            <pre>
context = {
    'books': books,              # List of books
    'total_books': 42,           # Count
    'search_query': 'Python',    # For displaying search term
    'filter_status': 'available' # For showing active filter
}
return render(request, 'myapp/book_list.html', context)
            </pre>
            <p><strong>Why pass all this information?</strong></p>
            <ul>
                <li><code>books</code> ‚Äì What to display in the list</li>
                <li><code>total_books</code> ‚Äì Show count badge</li>
                <li><code>search_query</code> ‚Äì Keep search term in input field (persistence)</li>
                <li><code>filter_status</code> ‚Äì Keep selected filter marked (persistence)</li>
            </ul>
            <p><strong>Persistence Example in Template:</strong></p>
            <pre>
&lt;input name="search" value="{{ search_query }}" /&gt;
&lt;select name="status"&gt;
    &lt;option value="all" {% if filter_status == 'all' %}selected{% endif %}&gt;All&lt;/option&gt;
    &lt;option value="available" {% if filter_status == 'available' %}selected{% endif %}&gt;Available&lt;/option&gt;
&lt;/select&gt;
            </pre>
            <p>This shows the previously selected values when user submits the form again!</p>
        </div>

        <div class="concept-box">
            <h4>11. Redirect Logic ‚Äì POST-Redirect-GET Pattern</h4>
            <p><strong>The Problem:</strong> If we don't redirect after POST, refreshing page resubmits form!</p>
            <pre>
# Bad: User refreshes = duplicate record created
form.save()
return render(request, 'myapp/book_list.html', context)  # ‚ùå Don't do this

# Good: User refreshes = just reloads the list (no duplicate)
form.save()
return redirect('myapp:book_list')  # ‚úì Redirects to GET request
            </pre>
            <p><strong>Why "POST-Redirect-GET"?</strong></p>
            <ul>
                <li>POST is used only for form submission (changes data)</li>
                <li>After saving, we redirect to GET request (safe, idempotent)</li>
                <li>User's final page load is a GET (refreshing = no side effects)</li>
                <li>Prevents accidental duplicate submissions</li>
            </ul>
            <p><strong>Always use redirect() after modifying data:</strong></p>
            <pre>
# CREATE
return redirect('myapp:book_list')  # Go back to list

# UPDATE
return redirect('myapp:book_detail', pk=book.pk)  # Show updated book

# DELETE
return redirect('myapp:book_list')  # Back to list
            </pre>
        </div>
    </section>

    <section id="summary">
        <h2>High-Level Changes Compared to Phase 1</h2>
        <table>
            <thead>
            <tr>
                <th>Artifact</th>
                <th>Phase 1</th>
                <th>Phase 2 (What Changes)</th>
                <th>Backend Concept</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><code>myapp/forms.py</code></td>
                <td>Didn't exist</td>
                <td>New `BookForm` with validation</td>
                <td>ModelForm architecture, form widgets, built-in validation</td>
            </tr>
            <tr>
                <td><code>myapp/views.py</code></td>
                <td><code>book_list</code> only (read-only)</td>
                <td>Add <code>create_book</code>, <code>edit_book</code>, <code>delete_book</code>, enhance <code>book_list</code></td>
                <td>GET vs POST handling, form processing, messages framework</td>
            </tr>
            <tr>
                <td><code>myapp/urls.py</code></td>
                <td>Only <code>path('books/', ...)</code></td>
                <td>Add create, edit, delete routes</td>
                <td>URL naming convention, URL parameters (pk)</td>
            </tr>
            <tr>
                <td>Templates</td>
                <td>Only <code>book_list.html</code></td>
                <td>Add <code>book_form.html</code>, <code>book_confirm_delete.html</code></td>
                <td>Form rendering, error display, reusable templates</td>
            </tr>
            <tr>
                <td>Search/Filter</td>
                <td>None</td>
                <td>Search across title/author/isbn + availability filter</td>
                <td>Q objects, QuerySet chaining, GET parameters</td>
            </tr>
            </tbody>
        </table>
    </section>

    <section id="backend-architecture">
        <h2>Phase 2 Backend Architecture Overview</h2>

        <h3>How CRUD Operations Flow</h3>
        <p><strong>CREATE Flow:</strong></p>
        <pre>
User clicks "Add Book"
‚Üì
GET request to /books/create/
‚Üì
View: book = BookForm()  (empty form)
‚Üì
Template renders empty form
‚Üì
User fills form and clicks Submit
‚Üì
POST request to /books/create/
‚Üì
View: form = BookForm(request.POST)  (form with data)
‚Üì
View: if form.is_valid():
        form.save()  (INSERT into database)
        messages.success(...)
        redirect to book_list
‚Üì
GET request to /books/  (refreshed with new book)
        </pre>

        <h3>UPDATE Flow:</h3>
        <pre>
User clicks "Edit" on a book
‚Üì
GET request to /books/5/edit/
‚Üì
View: book = get_object_or_404(Book, pk=5)
      form = BookForm(instance=book)  (pre-filled)
‚Üì
Template renders form with existing values
‚Üì
User changes values and clicks Submit
‚Üì
POST request to /books/5/edit/
‚Üì
View: book = get_object_or_404(Book, pk=5)
      form = BookForm(request.POST, instance=book)
‚Üì
View: if form.is_valid():
        form.save()  (UPDATE database)
        messages.success(...)
        redirect to book_list
‚Üì
GET request to /books/
        </pre>

        <h3>DELETE Flow:</h3>
        <pre>
User clicks "Delete" on a book
‚Üì
GET request to /books/5/delete/
‚Üì
View: displays confirmation page
‚Üì
User clicks "Yes, Delete"
‚Üì
POST request to /books/5/delete/
‚Üì
View: book.delete()  (DELETE from database)
      messages.success(...)
      redirect to book_list
‚Üì
GET request to /books/  (book is gone)
        </pre>

        <p><strong>Notice the pattern:</strong></p>
        <ul>
            <li>All modify operations (POST) end with redirect to GET request</li>
            <li>Each action stores the book's primary key (pk) in the URL</li>
            <li>GET requests display forms/confirmations</li>
            <li>POST requests process data and redirect</li>
        </ul>
    </section>

    <section id="form-concepts">
        <h2>Django Forms Deep Dive</h2>

        <h3>Form Field Types & Widgets</h3>
        <p><strong>Form fields determine:</strong></p>
        <ul>
            <li>What input type appears in HTML (text, number, select, etc.)</li>
            <li>How to validate the data</li>
            <li>How to convert string input to Python types</li>
        </ul>

        <table>
            <tr>
                <th>Form Field</th>
                <th>HTML Input Type</th>
                <th>Validates</th>
                <th>Converts To</th>
            </tr>
            <tr>
                <td><code>CharField</code></td>
                <td>&lt;input type="text" /&gt;</td>
                <td>String length</td>
                <td>String</td>
            </tr>
            <tr>
                <td><code>IntegerField</code></td>
                <td>&lt;input type="number" /&gt;</td>
                <td>Is it a valid integer?</td>
                <td>Integer</td>
            </tr>
            <tr>
                <td><code>EmailField</code></td>
                <td>&lt;input type="email" /&gt;</td>
                <td>Valid email format?</td>
                <td>String</td>
            </tr>
            <tr>
                <td><code>ChoiceField</code></td>
                <td>&lt;select&gt; dropdown</td>
                <td>Is value in choices?</td>
                <td>String</td>
            </tr>
            <tr>
                <td><code>BooleanField</code></td>
                <td>&lt;input type="checkbox" /&gt;</td>
                <td>On or off?</td>
                <td>Boolean</td>
            </tr>
        </table>

        <h3>Widgets ‚Äì Customizing HTML Appearance</h3>
        <p><strong>A field can have different widgets (HTML representations):</strong></p>
        <pre>
# Default: text input
title = forms.CharField()

# With widget customization:
title = forms.CharField(
    widget=forms.TextInput(attrs={
        'class': 'form-control',           # CSS class
        'placeholder': 'Enter title',      # Placeholder text
        'required': True                   # HTML attribute
    })
)
        </pre>
        <p>The field type (CharField) stays the same, but the widget (how it appears) changes.</p>

        <h3>Form Cleaning & Validation Order</h3>
        <p><strong>Django calls these methods in order:</strong></p>
        <pre>
1. Field clean() methods (built-in)
   - CharField: max_length check
   - EmailField: valid email check
   - IntegerField: is it a number check

2. clean_&lt;fieldname&gt;() methods (custom per field)
   def clean_isbn(self):
       isbn = self.cleaned_data.get('isbn')
       if not isbn.isdigit():
           raise forms.ValidationError("ISBN must contain only digits")
       return isbn

3. clean() method (cross-field validation)
   def clean(self):
       cd = self.cleaned_data
       if cd.get('password1') != cd.get('password2'):
           raise forms.ValidationError("Passwords don't match")
       return cd
        </pre>
        <p><strong>Key insight:</strong> Validation happens in layers. Early validations (field-level) reject quickly. Later validations (form-level) can check relationships between fields.</p>
    </section>

    <section id="request-response">
        <h2>Request & Response Handling</h2>

        <h3>The Request Object ‚Äì What Does It Contain?</h3>
        <p><strong>When user submits form with POST:</strong></p>
        <pre>
request.method       # 'GET' or 'POST' or 'PUT', etc.
request.POST         # Dictionary-like object of form data
request.GET          # Dictionary-like object of URL query parameters
request.user         # Logged-in user (Phase 4)
request.session      # Session data
request.META         # HTTP headers, remote IP, etc.
request.FILES        # Uploaded files (Phase 2+)
        </pre>

        <h3>Typical Form Processing Pattern</h3>
        <pre>
def create_book(request):
    if request.method == 'POST':
        # User submitted form
        form = BookForm(request.POST)
        
        # Check if data is valid
        if form.is_valid():
            # All validations passed
            book = form.save()  # Save to database
            messages.success(request, f"Book '{book.title}' created!")
            return redirect('myapp:book_list')
        # else: form.errors contains validation errors
        #       template will display them
    
    else:
        # GET request - display empty form
        form = BookForm()
    
    # Both GET (empty) and POST (with errors) render this template
    context = {'form': form, 'title': 'Add New Book'}
    return render(request, 'myapp/book_form.html', context)
        </pre>

        <h3>Why Same View Handles Both GET & POST?</h3>
        <ul>
            <li><code>GET</code>: Display empty form for user to fill</li>
            <li><code>POST</code> (valid): Save data, redirect to success page</li>
            <li><code>POST</code> (invalid): Display form again with error messages</li>
        </ul>
        <p>This saves code duplication and keeps related logic together.</p>
    </section>

    <section id="oqm-deep-dive">
        <h2>QuerySet Operations ‚Äì Understanding Database Interactions</h2>

        <h3>When Are Database Queries Actually Executed?</h3>
        <p><strong>Django QuerySets are LAZY ‚Äì queries don't run until needed:</strong></p>
        <pre>
# No query yet (just a QuerySet object)
books = Book.objects.filter(quantity__gt=0)

# Query NOT executed yet
books = books.filter(author__icontains='Python')

# Still no query!
books = books.order_by('created_at')

# QUERY EXECUTED HERE (template iteration)
{% for book in books %}
    {{ book.title }}
{% endfor %}

# OR here (accessing results):
count = books.count()
list_of_books = list(books)
first_book = books.first()
        </pre>

        <h3>Chaining Filters ‚Äì Building Complex Queries</h3>
        <p><strong>Each .filter() narrows the result set with AND logic:</strong></p>
        <pre>
books = Book.objects.all()
# All books

books = books.filter(quantity__gt=0)
# AND quantity > 0

books = books.filter(author__icontains='Python')
# AND author contains 'Python'

# SQL equivalent: WHERE quantity > 0 AND author LIKE '%Python%'
        </pre>

        <h3>Exclude vs Filter</h3>
        <pre>
# Same as filter(quantity__gt=0)
available = Book.objects.filter(quantity__gt=0)

# Same as filter(quantity=0)
unavailable = Book.objects.exclude(quantity__gt=0)

# They're inverses of each other
        </pre>

        <h3>Ordering Results</h3>
        <pre>
# Newest first (descending)
Book.objects.order_by('-created_at')

# Oldest first (ascending)
Book.objects.order_by('created_at')

# Multiple fields
Book.objects.order_by('-created_at', 'title')  # By date desc, then title asc
        </pre>

        <h3>Aggregation & Counting</h3>
        <pre>
# Count total
Book.objects.count()

# Count with filter
Book.objects.filter(quantity__gt=0).count()

# Average quantity
from django.db.models import Avg
Book.objects.aggregate(Avg('quantity'))

# Count distinct authors
Book.objects.values('author').distinct().count()
        </pre>
    </section>

    <section id="best-practices-phase2">
        <h2>Phase 2 Backend Best Practices</h2>

        <div class="concept-box">
            <h4>1. Always Use ModelForm for Model-based Forms</h4>
            <p><strong>Why:</strong> DRY principle, automatic validation sync, form.save() works automatically</p>
        </div>

        <div class="concept-box">
            <h4>2. Separate Validation Into Layers</h4>
            <p><strong>Field validation:</strong> Check individual field values</p>
            <p><strong>Form validation:</strong> Check relationships between fields</p>
            <p><strong>Model validation:</strong> Database-level constraints</p>
        </div>

        <div class="concept-box">
            <h4>3. Always Use get_object_or_404()</h4>
            <p><strong>Don't:</strong> <code>book = Book.objects.get(pk=pk)</code> (crashes if not found)</p>
            <p><strong>Do:</strong> <code>book = get_object_or_404(Book, pk=pk)</code> (shows 404 page)</p>
        </div>

        <div class="concept-box">
            <h4>4. Redirect After POST (POST-Redirect-GET Pattern)</h4>
            <p><strong>Why:</strong> Prevents duplicate submissions on refresh</p>
        </div>

        <div class="concept-box">
            <h4>5. Use Messages for User Feedback</h4>
            <p><strong>Why:</strong> Users need to know if their action succeeded/failed</p>
        </div>

        <div class="concept-box">
            <h4>6. Cache Filter State in Context</h4>
            <p>Pass <code>search_query</code> and <code>filter_status</code> back to template so form values persist</p>
        </div>

        <div class="concept-box">
            <h4>7. Use Q Objects for Complex Filters</h4>
            <p><strong>Don't:</strong> Fetch all data and filter in Python (slow)</p>
            <p><strong>Do:</strong> Use Q objects to filter in database (fast)</p>
        </div>
    </section>

    <section id="next-steps">
        <h2>What's Next ‚Äì Phase 3 Preview</h2>
        <p>In Phase 3, you'll learn:</p>
        <ul>
            <li><strong>Database Relationships:</strong> ForeignKey and related_name for connecting models</li>
            <li><strong>Student Model:</strong> Similar CRUD operations for students</li>
            <li><strong>IssuedBook Model:</strong> Tracking which student has which book</li>
            <li><strong>Complex Validation:</strong> Ensure students can't borrow more books than available</li>
            <li><strong>Circular Logic:</strong> When book is issued, decrease quantity; when returned, increase it</li>
        </ul>
    </section>

    <section id="implementation-walkthrough">
        <h2>Implementation Walkthrough ‚Äì Step by Step</h2>

        <h3>1. Create the BookForm (`myapp/forms.py`)</h3>
        <pre>
from django import forms
from .models import Book

class BookForm(forms.ModelForm):
    class Meta:
        model = Book
        fields = ['title', 'author', 'isbn', 'quantity']
        widgets = {
            'title': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter book title',
                'required': True
            }),
            'author': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter author name',
                'required': True
            }),
            'isbn': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter ISBN (13 characters)',
                'maxlength': '13',
                'required': True
            }),
            'quantity': forms.NumberInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter quantity',
                'min': '0',
                'required': True
            }),
        }
        labels = {
            'title': 'Book Title',
            'author': 'Author Name',
            'isbn': 'ISBN',
            'quantity': 'Quantity',
        }</pre>
        <p>
            Using `ModelForm` keeps validation in sync with the model and ensures consistent form styling.
        </p>

        <h3>2. Enhance the Book List View (`myapp/views.py`)</h3>
        <pre>
def book_list(request):
    books = Book.objects.all()
    search_query = request.GET.get('search', '')
    filter_status = request.GET.get('status', 'all')

    if search_query:
        books = books.filter(
            Q(title__icontains=search_query) |
            Q(author__icontains=search_query) |
            Q(isbn__icontains=search_query)
        )

    if filter_status == 'available':
        books = books.filter(quantity__gt=0)
    elif filter_status == 'unavailable':
        books = books.filter(quantity=0)

    context = {
        'books': books,
        'total_books': Book.objects.count(),
        'available_books': Book.objects.filter(quantity__gt=0).count(),
        'search_query': search_query,
        'filter_status': filter_status,
    }
    return render(request, 'myapp/book_list.html', context)</pre>
        <ul>
            <li>`Q` objects allow OR searches on multiple fields.</li>
            <li>Filter drop-down helps discuss business logic (stocked vs out-of-stock).</li>
            <li>Context stores filter state for template persistence.</li>
        </ul>

        <h3>3. Create the CRUD Views</h3>
        <h4>Create</h4>
        <pre>
def create_book(request):
    if request.method == 'POST':
        form = BookForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, f"Book '{form.cleaned_data['title']}' created successfully!")
            return redirect('myapp:book_list')
    else:
        form = BookForm()

    context = {
        'form': form,
        'title': 'Add New Book',
        'button_text': 'Create Book'
    }
    return render(request, 'myapp/book_form.html', context)</pre>
        <p>
            Demonstrates GET vs POST workflow and how to redirect after success.
        </p>

        <h4>Edit</h4>
        <pre>
def edit_book(request, pk):
    book = get_object_or_404(Book, pk=pk)

    if request.method == 'POST':
        form = BookForm(request.POST, instance=book)
        if form.is_valid():
            form.save()
            messages.success(request, f"Book '{form.cleaned_data['title']}' updated successfully!")
            return redirect('myapp:book_list')
    else:
        form = BookForm(instance=book)

    context = {
        'form': form,
        'book': book,
        'title': f'Edit: {book.title}',
        'button_text': 'Update Book'
    }
    return render(request, 'myapp/book_form.html', context)</pre>
        <p>Key teaching points: how `instance` loads existing data and how to display object metadata in the template.</p>

        <h4>Delete</h4>
        <pre>
def delete_book(request, pk):
    book = get_object_or_404(Book, pk=pk)

    if request.method == 'POST':
        book_title = book.title
        book.delete()
        messages.success(request, f"Book '{book_title}' deleted successfully!")
        return redirect('myapp:book_list')

    context = {'book': book}
    return render(request, 'myapp/book_confirm_delete.html', context)</pre>
        <div class="callout">
            <strong>Teaching moment:</strong> Always require POST confirmation for destructive actions to avoid CSRF or accidental clicks.
        </div>

        <h3>4. Route the Views (`myapp/urls.py`)</h3>
        <pre>
urlpatterns = [
    path('books/', views.book_list, name='book_list'),          # from Phase 1
    path('books/create/', views.create_book, name='create_book'),
    path('books/&lt;int:pk&gt;/edit/', views.edit_book, name='edit_book'),
    path('books/&lt;int:pk&gt;/delete/', views.delete_book, name='delete_book'),
]</pre>
        <p>
            Emphasize the importance of URL names (`name='edit_book'`) for use in templates when generating links.
        </p>

        <h3>5. Build the Templates</h3>
        <h4>`book_form.html`</h4>
        <pre>
&lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;form method="post"&gt;
    {% csrf_token %}
    {{ form.non_field_errors }}
    &lt;div class="mb-3"&gt;
        {{ form.title.label_tag }}
        {{ form.title }}
        {{ form.title.errors }}
    &lt;/div&gt;
    ...
    &lt;button type="submit" class="btn btn-primary"&gt;{{ button_text }}&lt;/button&gt;
    &lt;a href="{% url 'myapp:book_list' %}" class="btn btn-secondary ms-2"&gt;Cancel&lt;/a&gt;
&lt;/form&gt;</pre>
        <ul>
            <li>Uses Bootstrap utility classes (students can adapt to other CSS frameworks).</li>
            <li>Labels, fields, and errors rendered individually for fine-grained control.</li>
        </ul>

        <h4>`book_confirm_delete.html`</h4>
        <pre>
&lt;h1&gt;Delete Book&lt;/h1&gt;
&lt;p&gt;Are you sure you want to delete &lt;strong&gt;{{ book.title }}&lt;/strong&gt;?&lt;/p&gt;
&lt;form method="post"&gt;
    {% csrf_token %}
    &lt;button type="submit" class="btn btn-danger"&gt;Yes, Delete&lt;/button&gt;
    &lt;a href="{% url 'myapp:book_list' %}" class="btn btn-secondary ms-2"&gt;Cancel&lt;/a&gt;
&lt;/form&gt;</pre>

        <h4>Updated `book_list.html` Highlights</h4>
        <pre>
&lt;form method="get" class="row g-3 mb-4"&gt;
    &lt;div class="col-md-6"&gt;
        &lt;input type="text" name="search" value="{{ search_query }}" class="form-control"
               placeholder="Search by title, author, ISBN"&gt;
    &lt;/div&gt;
    &lt;div class="col-md-3"&gt;
        &lt;select name="status" class="form-select"&gt;
            &lt;option value="all" {% if filter_status == 'all' %}selected{% endif %}&gt;All&lt;/option&gt;
            &lt;option value="available" {% if filter_status == 'available' %}selected{% endif %}&gt;Available&lt;/option&gt;
            &lt;option value="unavailable" {% if filter_status == 'unavailable' %}selected{% endif %}&gt;Unavailable&lt;/option&gt;
        &lt;/select&gt;
    &lt;/div&gt;
    &lt;div class="col-md-3"&gt;
        &lt;button class="btn btn-primary w-100" type="submit"&gt;Apply&lt;/button&gt;
    &lt;/div&gt;
&lt;/form&gt;

&lt;a href="{% url 'myapp:create_book' %}" class="btn btn-success mb-3"&gt;Add Book&lt;/a&gt;

&lt;table class="table table-striped"&gt;
    ...
    &lt;td class="text-end"&gt;
        &lt;a href="{% url 'myapp:edit_book' book.pk %}" class="btn btn-sm btn-outline-primary me-2"&gt;Edit&lt;/a&gt;
        &lt;a href="{% url 'myapp:delete_book' book.pk %}" class="btn btn-sm btn-outline-danger"&gt;Delete&lt;/a&gt;
    &lt;/td&gt;
&lt;/tr&gt;</pre>
        <p>
            Discuss how query parameters are preserved, and how to build clean user flows from list ‚Üí form ‚Üí list.
        </p>
    </section>

    <section id="testing">
        <h2>Testing &amp; Verification Steps</h2>
        <ol>
            <li>Open <code>/books/</code> and ensure the filter + search operate correctly.</li>
            <li>Create a new book via `/books/create/`; verify success message and list update.</li>
            <li>Edit an existing book and confirm the changed fields persist.</li>
            <li>Delete a book using the confirmation page; confirm removal from the table.</li>
            <li>Attempt to submit invalid data (e.g., empty title) to demonstrate validation errors.</li>
        </ol>
    </section>

    <section id="commands">
        <h2>Terminal Commands Recap</h2>
        <pre>
# Start server
python manage.py runserver

# Create admin user (if not done in Phase 1)
python manage.py createsuperuser

# Optional: inspect migrations
python manage.py showmigrations myapp
        </pre>
    </section>

    <section id="teaching-tips">
        <h2>Instructor Tips</h2>
        <ul>
            <li>Explain CSRF protection when discussing POST forms.</li>
            <li>Encourage students to refactor repeated layout into base templates (prep for later phases).</li>
            <li>Highlight how Django messages improve UX and guide the user‚Äôs next action.</li>
            <li>Discuss potential validation enhancements (e.g., ISBN length custom clean method).</li>
            <li>Preview Phase 3 by mentioning that similar CRUD patterns will apply to students and issue records.</li>
        </ul>
    </section>

    <section id="key-takeaways">
        <h2>Phase 2 Key Takeaways</h2>
        <div class="concept-box">
            <p><strong>‚úì ModelForm:</strong> Always use for model-backed forms. Handles validation + saving.</p>
        </div>
        <div class="concept-box">
            <p><strong>‚úì GET vs POST:</strong> GET = display, POST = process. Always redirect after POST.</p>
        </div>
        <div class="concept-box">
            <p><strong>‚úì Validation Layers:</strong> Field ‚Üí Form ‚Üí Model. Each layer adds protection.</p>
        </div>
        <div class="concept-box">
            <p><strong>‚úì QuerySets are Lazy:</strong> Filters don't execute until iteration or .count(). Optimize in database, not Python.</p>
        </div>
        <div class="concept-box">
            <p><strong>‚úì Q Objects:</strong> Use for OR logic: <code>Q(field1=x) | Q(field2=y)</code></p>
        </div>
        <div class="concept-box">
            <p><strong>‚úì Messages Framework:</strong> Always tell users if action succeeded or failed.</p>
        </div>
    </section>
</main>
<footer>
    <h3>Phase 2 Complete! üéâ</h3>
    <p>You've mastered CRUD operations, Django forms, form validation, and the messages framework.</p>
    <p>Your library system can now create, read, update, and delete books with professional UX.</p>
    <p><strong>Next:</strong> Phase 3 ‚Äì Database relationships, students, and issue/return workflows!</p>
</footer>
</body>
</html>

